

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../_static/favicon.ico">
    
    
      
        <title>The Finite Element Method - Physics Based Animation Toolkit</title>
      
    
    
      
        
        
      
      

    
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../_static/sphinx_immaterial_theme.b454d0e296e565629.min.css" />
        <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
        <link rel="stylesheet" type="text/css" href="../_static/autoclasstoc.css" />
        <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="deep-purple">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#introduction" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../index.html" title="Physics Based Animation Toolkit" class="md-header__button md-logo" aria-label="Physics Based Animation Toolkit" data-md-component="logo">
      <img src="../_static/pbat.svg" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Physics Based Animation Toolkit
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              The Finite Element Method
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="deep-purple" data-md-color-accent="deep-purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="deep-purple"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/Q-Minh/PhysicsBasedAnimationToolkit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Q-Minh/PhysicsBasedAnimationToolkit
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../index.html" class="md-tabs__link">
      <span class="md-ellipsis">General</span>
    </a>
  </li>

      
        
  
  
    
  


  <li class="md-tabs__item">
    <a href="getting_started.html" class="md-tabs__link md-tabs__link--active">
      <span class="md-ellipsis">Tutorial</span>
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../contributing.html" class="md-tabs__link">
      <span class="md-ellipsis">Developers</span>
    </a>
  </li>

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Physics Based Animation Toolkit" class="md-nav__button md-logo" aria-label="Physics Based Animation Toolkit" data-md-component="logo">
      <img src="../_static/pbat.svg" alt="logo">
    </a>
    Physics Based Animation Toolkit
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/Q-Minh/PhysicsBasedAnimationToolkit" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    Q-Minh/PhysicsBasedAnimationToolkit
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
        <label class="md-nav__link" for="__nav_1">
          <span class="md-ellipsis">General</span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="General" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">General</span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        <span title="/index.rst (reference label)" class="md-ellipsis">Home</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog.html" class="md-nav__link">
        <span title="/changelog.rst (reference label)" class="md-ellipsis">Changelog</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../license.html" class="md-nav__link">
        <span title="/license.rst (reference label)" class="md-ellipsis">License</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2">
          <span class="md-ellipsis">Tutorial</span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Tutorial" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Tutorial</span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="getting_started.html" class="md-nav__link">
        <span title="/tutorial/getting_started.rst (reference label)" class="md-ellipsis">Tutorial</span>
      </a>
    </li>
  

            
          
            
              
  
  
    
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          <span title="/tutorial/fem.rst (reference label)" class="md-ellipsis">The Finite Element Method</span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="#" class="md-nav__link md-nav__link--active">
        <span title="/tutorial/fem.rst (reference label)" class="md-ellipsis">The Finite Element Method</span>
      </a>
      
        

  

<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span title="/tutorial/fem.rst#introduction (reference label)" class="md-ellipsis">Introduction</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#prerequisites" class="md-nav__link">
    <span title="/tutorial/fem.rst#prerequisites (reference label)" class="md-ellipsis">Prerequisites</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#method" class="md-nav__link">
    <span title="/tutorial/fem.rst#method (reference label)" class="md-ellipsis">Method</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motivation" class="md-nav__link">
    <span title="/tutorial/fem.rst#motivation (reference label)" class="md-ellipsis">Motivation</span>
  </a>
  
    <nav class="md-nav" aria-label="Motivation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span title="/tutorial/fem.rst#summary (reference label)" class="md-ellipsis">Summary</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-functions" class="md-nav__link">
    <span title="/tutorial/fem.rst#shape-functions (reference label)" class="md-ellipsis">Shape functions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mapping-from-to-reference" class="md-nav__link">
    <span title="/tutorial/fem.rst#mapping-from-to-reference (reference label)" class="md-ellipsis">Mapping from/to reference</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#derivatives" class="md-nav__link">
    <span title="/tutorial/fem.rst#derivatives (reference label)" class="md-ellipsis">Derivatives</span>
  </a>
  
    <nav class="md-nav" aria-label="Derivatives">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#id2" class="md-nav__link">
    <span title="/tutorial/fem.rst#id2 (reference label)" class="md-ellipsis">Summary</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spatial-integration" class="md-nav__link">
    <span title="/tutorial/fem.rst#spatial-integration (reference label)" class="md-ellipsis">Spatial integration</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#operators" class="md-nav__link">
    <span title="/tutorial/fem.rst#operators (reference label)" class="md-ellipsis">Operators</span>
  </a>
  
    <nav class="md-nav" aria-label="Operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shape-function-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#shape-function-matrix (reference label)" class="md-ellipsis">Shape function matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadrature-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#quadrature-matrix (reference label)" class="md-ellipsis">Quadrature matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load-vector" class="md-nav__link">
    <span title="/tutorial/fem.rst#load-vector (reference label)" class="md-ellipsis">Load vector</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mass-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#mass-matrix (reference label)" class="md-ellipsis">Mass matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#gradient-matrix (reference label)" class="md-ellipsis">Gradient matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#laplacian-matrix (reference label)" class="md-ellipsis">Laplacian matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divergence-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#divergence-matrix (reference label)" class="md-ellipsis">Divergence matrix</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary-conditions" class="md-nav__link">
    <span title="/tutorial/fem.rst#boundary-conditions (reference label)" class="md-ellipsis">Boundary conditions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector-valued-functions" class="md-nav__link">
    <span title="/tutorial/fem.rst#vector-valued-functions (reference label)" class="md-ellipsis">Vector-<wbr>valued functions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#limitations" class="md-nav__link">
    <span title="/tutorial/fem.rst#limitations (reference label)" class="md-ellipsis">Limitations</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#workshops" class="md-nav__link">
    <span title="/tutorial/fem.rst#workshops (reference label)" class="md-ellipsis">Workshops</span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
        <label class="md-nav__link" for="__nav_3">
          <span class="md-ellipsis">Developers</span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Developers" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Developers</span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../contributing.html" class="md-nav__link">
        <span title="/contributing.rst (reference label)" class="md-ellipsis">Contributing</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../style_guide.html" class="md-nav__link">
        <span title="/style_guide.rst (reference label)" class="md-ellipsis">Style Guide</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../code_of_conduct.html" class="md-nav__link">
        <span title="/code_of_conduct.rst (reference label)" class="md-ellipsis">Code of Conduct</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  

<nav class="md-nav md-nav--secondary">
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span title="/tutorial/fem.rst#introduction (reference label)" class="md-ellipsis">Introduction</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#prerequisites" class="md-nav__link">
    <span title="/tutorial/fem.rst#prerequisites (reference label)" class="md-ellipsis">Prerequisites</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#method" class="md-nav__link">
    <span title="/tutorial/fem.rst#method (reference label)" class="md-ellipsis">Method</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#motivation" class="md-nav__link">
    <span title="/tutorial/fem.rst#motivation (reference label)" class="md-ellipsis">Motivation</span>
  </a>
  
    <nav class="md-nav" aria-label="Motivation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#summary" class="md-nav__link">
    <span title="/tutorial/fem.rst#summary (reference label)" class="md-ellipsis">Summary</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shape-functions" class="md-nav__link">
    <span title="/tutorial/fem.rst#shape-functions (reference label)" class="md-ellipsis">Shape functions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mapping-from-to-reference" class="md-nav__link">
    <span title="/tutorial/fem.rst#mapping-from-to-reference (reference label)" class="md-ellipsis">Mapping from/to reference</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#derivatives" class="md-nav__link">
    <span title="/tutorial/fem.rst#derivatives (reference label)" class="md-ellipsis">Derivatives</span>
  </a>
  
    <nav class="md-nav" aria-label="Derivatives">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#id2" class="md-nav__link">
    <span title="/tutorial/fem.rst#id2 (reference label)" class="md-ellipsis">Summary</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#spatial-integration" class="md-nav__link">
    <span title="/tutorial/fem.rst#spatial-integration (reference label)" class="md-ellipsis">Spatial integration</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#operators" class="md-nav__link">
    <span title="/tutorial/fem.rst#operators (reference label)" class="md-ellipsis">Operators</span>
  </a>
  
    <nav class="md-nav" aria-label="Operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#shape-function-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#shape-function-matrix (reference label)" class="md-ellipsis">Shape function matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadrature-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#quadrature-matrix (reference label)" class="md-ellipsis">Quadrature matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load-vector" class="md-nav__link">
    <span title="/tutorial/fem.rst#load-vector (reference label)" class="md-ellipsis">Load vector</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mass-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#mass-matrix (reference label)" class="md-ellipsis">Mass matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#gradient-matrix (reference label)" class="md-ellipsis">Gradient matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#laplacian-matrix (reference label)" class="md-ellipsis">Laplacian matrix</span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#divergence-matrix" class="md-nav__link">
    <span title="/tutorial/fem.rst#divergence-matrix (reference label)" class="md-ellipsis">Divergence matrix</span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#boundary-conditions" class="md-nav__link">
    <span title="/tutorial/fem.rst#boundary-conditions (reference label)" class="md-ellipsis">Boundary conditions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector-valued-functions" class="md-nav__link">
    <span title="/tutorial/fem.rst#vector-valued-functions (reference label)" class="md-ellipsis">Vector-<wbr>valued functions</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#limitations" class="md-nav__link">
    <span title="/tutorial/fem.rst#limitations (reference label)" class="md-ellipsis">Limitations</span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#workshops" class="md-nav__link">
    <span title="/tutorial/fem.rst#workshops (reference label)" class="md-ellipsis">Workshops</span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                  


  <a href="https://github.com/Q-Minh/PhysicsBasedAnimationToolkit/blob/main/docs/source/tutorial/fem.rst" title="Edit this page" class="md-content__button md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
  </a>

<h1 id="the-finite-element-method">The Finite Element Method<a class="headerlink" href="#the-finite-element-method" title="Permalink to this heading">¶</a></h1>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">¶</a></h2>
<p>The Finite Element Method (FEM) is an approach to discretizing space-dependent continuous problems defined on geometrically “complex” domains. As opposed to Finite Differences (FD), which is restricted to regular grid domains, FEM relies on <a class="reference external" href="https://en.wikipedia.org/wiki/Mesh_generation">meshing</a> the problem’s domain (geometric discretization), describing the problem’s solution as a linear combination of piece-wise (i.e. per mesh element) interpolating polynomials (functional discretization), and solving the approximated problem on the mesh. The “Finite” in FEM comes from limiting the approximate solution to be spanned by a “finite-dimensional” functional basis, i.e. the one spanned by the element-wise interpolating polynomials (the basis functions). The “Element” in FEM comes from the polynomials being entirely constructed/defined by the simple geometric primitives composing the mesh, called “elements”.</p>
<h2 id="prerequisites">Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading">¶</a></h2>
<ul class="simple">
<li><p>Calculus</p></li>
<li><p>Linear Algebra</p></li>
<li><p>Differential equations (optional)</p></li>
</ul>
<h2 id="method">Method<a class="headerlink" href="#method" title="Permalink to this heading">¶</a></h2>
<p>Given some space-dependent problem whose solution <span class="math notranslate nohighlight">\(u(X)\)</span> is defined on some continuous domain <span class="math notranslate nohighlight">\(\Omega\)</span>, FEM first requires a <em>geometric mesh</em> <span class="math notranslate nohighlight">\((V,C) \approx \Omega\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is a set of cells whose vertices are in <span class="math notranslate nohighlight">\(V\)</span>. From <span class="math notranslate nohighlight">\((V,C)\)</span>, we then construct the <em>FEM mesh</em> <span class="math notranslate nohighlight">\((I,E)\)</span>, where <span class="math notranslate nohighlight">\(I\)</span> is the set of FEM <em>nodes</em> and <span class="math notranslate nohighlight">\(E\)</span> is the set of FEM <em>elements</em>. We now assume that the geometric mesh is the domain itself <span class="math notranslate nohighlight">\((V,C)=\Omega\)</span>.</p>
<p>Nodes <span class="math notranslate nohighlight">\(i \in I\)</span> have corresponding positions <span class="math notranslate nohighlight">\(X_i \in \Omega\)</span> and associated <em>basis functions</em> <span class="math notranslate nohighlight">\(\phi_i(X): \Omega \longrightarrow \mathbb{R}\)</span> such that <span class="math notranslate nohighlight">\(\phi_i(X_j) = \delta_{ij}\)</span>, where <span class="math notranslate nohighlight">\(\delta_{ij}\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta</a>. Such basis functions are defined element-wise by so-called <em>shape functions</em> <span class="math notranslate nohighlight">\(N_i^e(X)\)</span> for pairs <span class="math notranslate nohighlight">\((i,e)\)</span> of adjacent node and element, and vanish in non-adjacent elements. In other words, the support of <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is the union of its adjacent elements, and evaluating <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> amounts to finding the element <span class="math notranslate nohighlight">\(e\)</span> containing the evaluation point <span class="math notranslate nohighlight">\(X\)</span>, and evaluating <span class="math notranslate nohighlight">\(N_i^e(X)\)</span> there. It is common to refer to this choice of basis function <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> as the “hat” function, because its tip (i.e. its maximal value of <span class="math notranslate nohighlight">\(1\)</span>) is located on node <span class="math notranslate nohighlight">\(i\)</span>, “centered” in its support, while it smoothly decreases to 0 at surrounding nodes. It is also common to refer to these elements as “PK Lagrange elements”, because their shape functions <span class="math notranslate nohighlight">\(N_i^e(X)\)</span> are interpolating polynomials of degree <span class="math notranslate nohighlight">\(K\)</span>.</p>
<figure class="align-center" id="id4">
<img alt="../_images/geometric.mesh.vs.fem.mesh.jpg" src="../_images/geometric.mesh.vs.fem.mesh.jpg" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
Geometric mesh (left) versus FEM meshes discretized with linear (middle) and quadratic (right) Lagrange elements.</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></figcaption>
</figure>
<p>With <span class="math notranslate nohighlight">\(n=|I|\)</span>, FEM restricts <span class="math notranslate nohighlight">\(u(X)\)</span> to the class of functions <span class="math notranslate nohighlight">\(u(X) = \sum_{i=1}^{n} u_i \phi_i(X)\)</span>, i.e. linear combinations of coefficients <span class="math notranslate nohighlight">\(u_i\)</span> and basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span> associated with nodes <span class="math notranslate nohighlight">\(i\)</span>. More compactly, <span class="math notranslate nohighlight">\(u(X) = \Phi^T u\)</span>, where</p>
<div class="math notranslate nohighlight">
\[u = \begin{bmatrix}u_1 &amp; \dots &amp; u_{n} \end{bmatrix}^T \in \mathbb{R}^{n}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\Phi = \begin{bmatrix} \phi_1(X) &amp; \dots &amp; \phi_{n}(X) \end{bmatrix}^T \in \mathbb{R}^{n}.\]</div>
<p>We say that the basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span> span the function space</p>
<div class="math notranslate nohighlight">
\[\{ \Phi^T u \;\forall\; u \in \mathbb{R}^{n} \},\]</div>
<p>much like basis vectors <span class="math notranslate nohighlight">\(v_i\)</span> span vector spaces <span class="math notranslate nohighlight">\(V\)</span>. Functions in the FEM function space, i.e. the space spanned by <span class="math notranslate nohighlight">\(\phi_i\)</span>, are uniquely represented by their vector of coefficients <span class="math notranslate nohighlight">\(u\)</span>, much like vectors <span class="math notranslate nohighlight">\(v = v_1 \overrightarrow{i} + v_2\overrightarrow{j} + v_3 \overrightarrow{k}\)</span> in <span class="math notranslate nohighlight">\(\mathbb{R}^3\)</span> are uniquely represented by their coefficients <span class="math notranslate nohighlight">\(\begin{bmatrix} v_1 &amp; v_2 &amp; v_3 \end{bmatrix}\)</span>.</p>
<figure class="align-center" id="id5">
<img alt="../_images/fem1D.gif" src="../_images/fem1D.gif" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
FEM function space in 1D using linear “hat” basis functions.</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></figcaption>
</figure>
<p>Such a discrete functional representation allows one to accurately map continuous problems from theory onto computers by needing only to store the discrete and finite-dimensional coefficients <span class="math notranslate nohighlight">\(u\)</span> and FEM mesh <span class="math notranslate nohighlight">\((I,E)\)</span>, assuming an appropriate geometric meshing of the problem domain is readily available. Furthermore, the linearity of <span class="math notranslate nohighlight">\(u(X)\)</span> with respect to <span class="math notranslate nohighlight">\(\Phi\)</span> naturally translates solving FEM-discretized problems into solving matrix equations.</p>
<h2 id="motivation">Motivation<a class="headerlink" href="#motivation" title="Permalink to this heading">¶</a></h2>
<p>As a motivating example, consider a well-known partial differential equation (PDE), the Poisson equation,</p>
<div class="math notranslate nohighlight">
\[\Delta u(X) = f(X),\]</div>
<p>defined on some domain <span class="math notranslate nohighlight">\(\Omega\)</span>, where <span class="math notranslate nohighlight">\(\Delta\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Laplace_operator#:~:text=In%20mathematics%2C%20the%20Laplace%20operator,scalar%20function%20on%20Euclidean%20space">Laplacian</a> and <span class="math notranslate nohighlight">\(f(X)\)</span> is some known function in space. In other words, we wish to solve for some function <span class="math notranslate nohighlight">\(u(X)\)</span> whose Laplacian is given by <span class="math notranslate nohighlight">\(f(X)\)</span> everywhere in <span class="math notranslate nohighlight">\(\Omega\)</span> (i.e. <span class="math notranslate nohighlight">\(\forall\; X \in \Omega\)</span>). Without further analytical specification on the domain <span class="math notranslate nohighlight">\(\Omega\)</span>, there is little we can do to solve such a general problem. In fact, most domains that we care about and that appear in real life don’t have an analytical description. Even if we did have such a description of the domain, it might still be very hard to solve such a problem by hand. We do, however, have powerful meshing tools which can take human-authored complex geometry as input, and produce meshes that accurately approximate the domain as output.</p>
<p>Assuming we have such a mesh at hand, we can discretize the solution <span class="math notranslate nohighlight">\(u(X)\)</span> as described in the previous section, obtaining</p>
<div class="math notranslate nohighlight">
\[\Delta \left[ \sum_j u_j \phi_j(X) \right] = f(X)\]</div>
<div class="math notranslate nohighlight">
\[\sum_j u_j \Delta \phi_j(X) = f(X),\]</div>
<p>since only the basis functions <span class="math notranslate nohighlight">\(\phi_j(X)\)</span> are space-dependent. Unfortunately, there are now <span class="math notranslate nohighlight">\(n\)</span> unknowns for a single equation, which is an under-determined problem. However, we can transform this single equation into <span class="math notranslate nohighlight">\(n\)</span> equations by an operator called the Galerkin projection</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \sum_j u_j \Delta \phi_j(X) \phi_i(X) \partial \Omega = \int_{\Omega} f(X) \phi_i(X) \partial \Omega.\]</div>
<p>Much like the dot product <span class="math notranslate nohighlight">\(\langle a, b \rangle = a^T b\)</span> for vectors <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(\langle f, g \rangle = \int_{\Omega} f(X)g(X) \partial \Omega\)</span> for functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>. In this sense, much like we say that <span class="math notranslate nohighlight">\(a^T b\)</span> projects the vector <span class="math notranslate nohighlight">\(a\)</span> onto the vector <span class="math notranslate nohighlight">\(b\)</span>, then <span class="math notranslate nohighlight">\(\int_{\Omega} f(X) g(X) \partial \Omega\)</span> projects the function <span class="math notranslate nohighlight">\(f\)</span> onto the function <span class="math notranslate nohighlight">\(g\)</span>. Thus, omitting the dependence on <span class="math notranslate nohighlight">\(X\)</span> to simplify notation, such a projection reveals the <span class="math notranslate nohighlight">\(n\)</span> equations</p>
<div class="math notranslate nohighlight">
\[\sum_j u_j \langle \phi_i, \Delta \phi_j \rangle = \langle f, \phi_i \rangle\]</div>
<p>for <span class="math notranslate nohighlight">\(i=1,2,\dots,n\)</span>, matching the <span class="math notranslate nohighlight">\(n\)</span> unknowns <span class="math notranslate nohighlight">\(u_j\)</span> for <span class="math notranslate nohighlight">\(j=1,2,\dots,n\)</span>. The FEM’s functional discretization of <span class="math notranslate nohighlight">\(u\)</span> and the Galerkin projection thus yield a linear system of equations</p>
<div class="math notranslate nohighlight">
\[\sum_j A_{ij} u_j = f_i\]</div>
<p>where <span class="math notranslate nohighlight">\(A_{ij} = \int_{\Omega} \phi_i \Delta \phi_j \partial \Omega\)</span> and <span class="math notranslate nohighlight">\(f_i = \int_{\Omega} f \phi_i \partial \Omega\)</span>. In matrix notation,</p>
<div class="math notranslate nohighlight">
\[Au=f,\]</div>
<p>where <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and <span class="math notranslate nohighlight">\(f \in \mathbb{R}^n\)</span>. We can thus solve for <span class="math notranslate nohighlight">\(u\)</span> using one of the many available implementations of numerical algorithms for solving linear systems of equations.</p>
<p>&gt; Interestingly, the Galerkin method is essentially a residual minimization procedure in function space, much like it is often possible to minimize the residual <span class="math notranslate nohighlight">\(r=Ax-b\)</span> for solving linear systems of equations approximately. Given some functional equation <span class="math notranslate nohighlight">\(L(u(X))=0\)</span>, we know that approximating <span class="math notranslate nohighlight">\(u(X) \approx \Phi^T u\)</span> will yield some error, which manifests as a residual when passing through the functional <span class="math notranslate nohighlight">\(L\)</span>, i.e. <span class="math notranslate nohighlight">\(L(\Phi^T u) = r\)</span>. The Galerkin method then requires that <span class="math notranslate nohighlight">\(\langle r, \phi_i \rangle = 0\)</span> for each basis function <span class="math notranslate nohighlight">\(\phi_i\)</span>. In other words, we ask that the residual be orthogonal (i.e. perpendicular) to the function space spanned by <span class="math notranslate nohighlight">\(\phi_i\)</span>, i.e. any other function <span class="math notranslate nohighlight">\(\Phi^T v\)</span> in this space would yield a worse residual than our solution <span class="math notranslate nohighlight">\(\Phi^T u\)</span>. Similarly, with linear systems, we ask that <span class="math notranslate nohighlight">\(r\)</span> be orthogonal to each basis vector of the map <span class="math notranslate nohighlight">\(A\)</span>, i.e. each column of the matrix <span class="math notranslate nohighlight">\(A\)</span>. This yields <span class="math notranslate nohighlight">\(A^T r = A^T A x - A^T b= 0\)</span>, the well known <a class="reference external" href="https://en.wikipedia.org/wiki/Ordinary_least_squares#Normal_equations">normal equations</a>.</p>
<h3 id="summary">Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h3>
<p>This section showed how a hard-to-solve space-dependent continuous problem defined on a complex domain could be solved accurately using existing numerical techniques through FEM, thus motivating its usefulness in practice. The approach used in our example is called Galerkin FEM, which projects the approximated problem onto the function space used to discretize the solution. Petrov-Galerkin methods allow projecting the approximated problem onto a different function space, i.e. there are two sets of basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span> and <span class="math notranslate nohighlight">\(\psi_i\)</span>, for discretizing the solution and the problem, respectively. In some cases, a projection is not required, i.e. the problem itself already reveals the required number of equations.</p>
<h2 id="shape-functions">Shape functions<a class="headerlink" href="#shape-functions" title="Permalink to this heading">¶</a></h2>
<p>Although our motivating example shows how, armed with basis functions <span class="math notranslate nohighlight">\(\phi_i\)</span>, continuous problems reduce to discrete ones, we have yet to explicitly define such functions. However, we did <em>implicitly</em> define them by stating that they must satisfy the following properties</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\phi_i\)</span> is a polynomial</p></li>
<li><p><span class="math notranslate nohighlight">\(\phi_i(X_j) = \delta_{ij}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\phi_i(X) = \begin{cases}N_i^e(X) &amp; X \in \Omega^e, \text{node} \;i\; \text{and element} \;e\; \text{are adjacent}\\ 0 &amp; \text{otherwise}\end{cases}\)</span></p></li>
</ol>
<p>The third property introduces <span class="math notranslate nohighlight">\(\Omega^e\)</span>, which refers to the domain of element <span class="math notranslate nohighlight">\(e\)</span>, i.e. the space it occupies. Naturally, meshes are made of non-overlapping geometric primitives (i.e. the “elements” <span class="math notranslate nohighlight">\(\Omega^e\)</span>), connected through their boundaries. This means that evaluating <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is achieved by the following steps.</p>
<ol class="arabic simple">
<li><p>Find which element <span class="math notranslate nohighlight">\(e\)</span> contains the point <span class="math notranslate nohighlight">\(X\)</span>.</p></li>
<li><p>Evaluate <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>.</p></li>
</ol>
<p>Fortunately, our shape functions have <span class="math notranslate nohighlight">\(C^0\)</span> continuity at element boundaries, meaning <span class="math notranslate nohighlight">\(N_i^e(X) = N_i^{e'}(X)\)</span> on the boundary between adjacent elements <span class="math notranslate nohighlight">\(e\)</span> and <span class="math notranslate nohighlight">\(e'\)</span> (due to uniqueness of interpolating polynomials). Hence, if a point <span class="math notranslate nohighlight">\(X\)</span> lies on the boundary between 2 or more elements, we can pick any of these elements in step 1.</p>
<p>We now focus on the secret sauce, the element shape functions <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>. Properties 1. and 3. state that <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is a polynomial and evaluates to <span class="math notranslate nohighlight">\(N_i^e(X)\)</span> on the element <span class="math notranslate nohighlight">\(e\)</span>. Thus, <span class="math notranslate nohighlight">\(N_i^e(X)\)</span> is a polynomial on the element <span class="math notranslate nohighlight">\(e\)</span>. Polynomials can be written as linear combinations of basis polynomials <span class="math notranslate nohighlight">\(P_k(X)\)</span>. Suppose that <span class="math notranslate nohighlight">\(n^e = |\text{nodes}(e)|\)</span>, then if we have <span class="math notranslate nohighlight">\(n^e\)</span> such basis polynomials <span class="math notranslate nohighlight">\(P_k(X)\)</span>, and we have that</p>
<div class="math notranslate nohighlight">
\[N_i^e(X) = \sum_{j \in \text{nodes}(e)} \alpha_{ij} P_j(X).\]</div>
<p>More compactly,</p>
<div class="math notranslate nohighlight">
\[N_i^e(X) = P(X)^T \alpha_i,\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[P(X) = \begin{bmatrix} P_1(X) &amp; \dots &amp; P_{n^e}(X) \end{bmatrix}^T\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\alpha_i = \begin{bmatrix} \alpha_{i1} &amp; \dots &amp; \alpha_{in^e} \end{bmatrix}^T.\]</div>
<p>Property 2, i.e. the Kronecker delta property, thus translates into <span class="math notranslate nohighlight">\(N_i^e(X_j) = \delta_{ij}\)</span> on element <span class="math notranslate nohighlight">\(e\)</span>. Substituting <span class="math notranslate nohighlight">\(N_i^e(X_j)\)</span> for its polynomial expansion in the Kronecker delta property yields</p>
<div class="math notranslate nohighlight">
\[\begin{bmatrix} P(X_1) &amp; \dots &amp; P(X_{n^e}) \end{bmatrix}^T \begin{bmatrix} \alpha_1 &amp; \dots &amp; \alpha_{n^e} \end{bmatrix} = I_{n^e \times n^e},\]</div>
<p>where <span class="math notranslate nohighlight">\(I_{n^e \times n^e} \in \mathbb{R}^{n^e \times n^e}\)</span> is the identity matrix. In matrix notation,</p>
<div class="math notranslate nohighlight">
\[P^T \alpha = I_{n^e \times n^e},\]</div>
<p>where we have conveniently numbered the nodes of element <span class="math notranslate nohighlight">\(e\)</span> as <span class="math notranslate nohighlight">\(l=1,2,\dots,n^e\)</span>. This numbering choice is often referred to as the “local” indexing of the nodes of element <span class="math notranslate nohighlight">\(e\)</span>. The “global” indexing of these same nodes refers to the actual nodal indices <span class="math notranslate nohighlight">\(i\)</span> corresponding to local nodal indices <span class="math notranslate nohighlight">\(l\)</span>.</p>
<p>The polynomial basis generally has a quite simple analytical form. For example, taking the monomial basis in 1D for a quadratic polynomial yields <span class="math notranslate nohighlight">\(P_1(X) = 1, P_2(X) = X, P_3(X) = X^2\)</span>. A linear monomial basis in 3D yields <span class="math notranslate nohighlight">\(P_1(X)=1, P_2(X) = X_1, P_3(X) = X_2, P_4(X)=X_3\)</span>. These basis polynomials are thus super easy to evaluate, differentiate or integrate in code. What we really need is to find the coefficients <span class="math notranslate nohighlight">\(\alpha_{ij}\)</span> that will finalize our definition of the shape functions <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>. Fortunately, solving the Kronecker equation above amounts to computing the inverse of the transposed matrix of polynomials <span class="math notranslate nohighlight">\(P^T\)</span></p>
<div class="math notranslate nohighlight">
\[\alpha = P^{-T}.\]</div>
<p>Armed with each matrix <span class="math notranslate nohighlight">\(A\)</span> stored for its corresponding element in an FEM computer program, we can easily evaluate <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> by finding an element <span class="math notranslate nohighlight">\(e\)</span> adjacent to node <span class="math notranslate nohighlight">\(i\)</span> containing point <span class="math notranslate nohighlight">\(X\)</span>, converting global node index <span class="math notranslate nohighlight">\(i\)</span> into its corresponding local index <span class="math notranslate nohighlight">\(l\)</span>, and returning <span class="math notranslate nohighlight">\(P(X)^T \alpha_{l}\)</span>. Fortunately, these polynomial coefficient matrices <span class="math notranslate nohighlight">\(A\)</span> are to be precomputed only once, in parallel, for each element.</p>
<p>Unfortunately, <span class="math notranslate nohighlight">\(P^T\)</span> can easily become <a class="reference external" href="https://en.wikipedia.org/wiki/Condition_number">ill-conditioned</a>, which makes its inversion <a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_stability">numerically unstable</a>, especially for higher-order polynomial basis’. This phenomenon depends on the geometry of the mesh elements, i.e. the positions of the nodes <span class="math notranslate nohighlight">\(X_i\)</span>. Intuitively, ill-conditioning of <span class="math notranslate nohighlight">\(P^T\)</span> means that some of its coefficients are really large (in magnitude), and some of them are really small (in magnitude). Taking as an example the 1D quadratic monomial evaluated at some element’s node with position <span class="math notranslate nohighlight">\(X=1000\)</span>, we get that its corresponding row in <span class="math notranslate nohighlight">\(P^T\)</span> would be <span class="math notranslate nohighlight">\(\begin{bmatrix}1 &amp; 1000 &amp; 1000000\end{bmatrix}\)</span>. Clearly, this is ill-conditioned.</p>
<p>To address this issue, it is common in practice to define some map <span class="math notranslate nohighlight">\(X(\xi)\)</span> that takes points in some <em>reference</em> space to the domain <span class="math notranslate nohighlight">\(\Omega\)</span>, and its inverse <span class="math notranslate nohighlight">\(\xi(X) = X^{-1}(\xi)\)</span> such that we can construct shape functions in the reference space, where the geometry of the elements will yield well-conditioned <span class="math notranslate nohighlight">\(P^T\)</span>. In fact, this concept leads to defining the so-called <em>reference elements</em>. The maps <span class="math notranslate nohighlight">\(X(\xi)\)</span> and <span class="math notranslate nohighlight">\(\xi(X)\)</span> are then defined per-element, and always map from and to the reference element, respectively. Reference shape functions are subsequently defined on the reference element and constructed only once. Evaluating a basis function <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> on element <span class="math notranslate nohighlight">\(e\)</span> thus amounts to mapping <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(\xi\)</span> using element <span class="math notranslate nohighlight">\(e\)</span>’s inverse map <span class="math notranslate nohighlight">\(\xi(X)\)</span>, and then evaluating the reference shape function associated with node <span class="math notranslate nohighlight">\(i\)</span> of element <span class="math notranslate nohighlight">\(e\)</span>. Mathematically, assuming that <span class="math notranslate nohighlight">\(N_l(\xi)\)</span> is the reference shape function for domain node <span class="math notranslate nohighlight">\(i\)</span> associated with reference node <span class="math notranslate nohighlight">\(l\)</span> on the reference element, we have that</p>
<div class="math notranslate nohighlight">
\[\phi_i(X) = N_l(\xi(X)).\]</div>
<p><a class="reference external" href="https://hplgit.github.io/INF5620/doc/pub/main_fem.pdf#page=81.67">Chapter 9.3 of Hans Petter Langtangen’s FEM book</a> (highly recommend that book) provides the following pedagogical visuals, in which dots represent nodes of a quadratic FEM triangular element.</p>
<figure class="align-center" id="id6">
<img alt="../_images/p2.triangle.affine.map.png" src="../_images/p2.triangle.affine.map.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
Linear map from reference element (local) to domain element (global).</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></figcaption>
</figure>
<figure class="align-center" id="id7">
<img alt="../_images/p2.triangle.isoparametric.map.png" src="../_images/p2.triangle.isoparametric.map.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
Non-linear map from reference element (local) to domain element (global).</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></figcaption>
</figure>
<p>Perhaps the simplest and/or most popular type of reference element is the <a class="reference external" href="https://doc.comsol.com/5.3/doc/com.comsol.help.comsol/comsol_api_xmesh.40.4.html">Lagrange element</a>. This type of element is defined by a polynomial order <span class="math notranslate nohighlight">\(p\)</span> used to construct the shape functions. As described above, there must be as many polynomial bases as nodes for the inverse of <span class="math notranslate nohighlight">\(P^T\)</span> to exist, i.e. <span class="math notranslate nohighlight">\(P^T\)</span> must be square. Lagrange elements in 3D thus define their nodes with coordinates</p>
<div class="math notranslate nohighlight">
\[\xi_l \in \left\{ \left(\frac{a}{p}, \frac{b}{p}, \frac{c}{p}\right) \right\}``\]</div>
<p>and corresponding polynomial basis functions</p>
<div class="math notranslate nohighlight">
\[P_l \in \left\{ \xi_x^a \xi_y^b \xi_z^c \right\}``\]</div>
<p>for integer values <span class="math notranslate nohighlight">\(0 \leq a,b,c \leq p\)</span>, where they are used as powers. In 2D, we only use <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. In 1D, we reduce further to simply using <span class="math notranslate nohighlight">\(a\)</span>. Simplex elements, such as triangles and tetrahedra have the additional constraint <span class="math notranslate nohighlight">\(a+b+c \leq p\)</span>, whereas line segments, quadrilaterals and hexahedra do not.</p>
<p>Taken once again from <a class="reference external" href="https://hplgit.github.io/INF5620/doc/pub/main_fem.pdf#page=81.67">chapter 9.3 of Hans Petter Langtangen’s FEM book</a>, here are examples of Lagrange elements and their nodes in dimensions <code class="docutils literal notranslate"><span class="pre">1,2,3</span></code>.</p>
<figure class="align-center" id="id8">
<img alt="../_images/p1.lagrange.simplex.elements.png" src="../_images/p1.lagrange.simplex.elements.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
Linear Lagrange simplex elements.</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></figcaption>
</figure>
<figure class="align-center" id="id9">
<img alt="../_images/p2.lagrange.simplex.elements.png" src="../_images/p2.lagrange.simplex.elements.png" />
<figcaption>
<p><span class="caption-text"><span class="caption-text">
Quadratic Lagrange simplex elements.</span><a class="headerlink" href="#id9" title="Permalink to this image">¶</a></figcaption>
</figure>
<h2 id="mapping-from-to-reference">Mapping from/to reference<a class="headerlink" href="#mapping-from-to-reference" title="Permalink to this heading">¶</a></h2>
<p>Given exact reference node placements <span class="math notranslate nohighlight">\(\xi_l\)</span> and the polynomial basis functions <span class="math notranslate nohighlight">\(P_l(\xi)\)</span>, we can obtain our reference shape functions <span class="math notranslate nohighlight">\(N_l(\xi) = P(\xi)^T \alpha_l\)</span>. We can recover the map <span class="math notranslate nohighlight">\(X(\xi)\)</span> easily by simple interpolation of domain positions <span class="math notranslate nohighlight">\(X_i\)</span> of domain nodes and elements, <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(e\)</span>, stored on corresponding reference nodes <span class="math notranslate nohighlight">\(l\)</span> with positions <span class="math notranslate nohighlight">\(\xi_l\)</span> and shape functions <span class="math notranslate nohighlight">\(N_l(\xi)\)</span> on the reference element. Mathematically, we write the map as</p>
<div class="math notranslate nohighlight">
\[X(\xi) = X^e N(\xi),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[X^e = \begin{bmatrix} X_1 &amp; \dots &amp; X_{n^e} \end{bmatrix} \in \mathbb{R}^{d \times n^e}\]</div>
<p>are element <span class="math notranslate nohighlight">\(e\)</span>’s nodes’ positions <span class="math notranslate nohighlight">\(X_i\)</span>,</p>
<div class="math notranslate nohighlight">
\[N(\xi) = \begin{bmatrix} N_1(\xi) &amp; \dots &amp; N_{n^e}(\xi) \end{bmatrix}^T \in \mathbb{R}^{n^e}\]</div>
<p>are the reference shape functions evaluated at <span class="math notranslate nohighlight">\(\xi\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> is the number of embedding dimensions for <span class="math notranslate nohighlight">\(X_i\)</span>.</p>
<p>The inverse map <span class="math notranslate nohighlight">\(\xi(X)\)</span> is, however, not so trivial in the general case. One way to obtain <span class="math notranslate nohighlight">\(\xi(X)\)</span> numerically is by solving the non-linear least-squares problem</p>
<div class="math notranslate nohighlight">
\[\min_{\xi} || X - X(\xi) ||_2^2,\]</div>
<p>for which we can use a <a class="reference external" href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm">Gauss-Newton algorithm</a>. If the map <span class="math notranslate nohighlight">\(X(\xi)\)</span> is linear, however, its jacobian <span class="math notranslate nohighlight">\(J\)</span> must be constant. We can choose an arbitrary point around which to perform a Taylor expansion of <span class="math notranslate nohighlight">\(X(\xi)\)</span>, for example, the reference space’s origin <span class="math notranslate nohighlight">\(\xi_1 = 0\)</span>, which we know is mapped to <span class="math notranslate nohighlight">\(X_1\)</span> in Lagrange elements, revealing</p>
<div class="math notranslate nohighlight">
\[X(\xi) = X_1 + J \xi.\]</div>
<p>If the reference element’s dimensions match the domain’s embedding dimensions, <span class="math notranslate nohighlight">\(J\)</span> is square and</p>
<div class="math notranslate nohighlight">
\[\xi(X) = J^{-1} (X - X_1).\]</div>
<p>Otherwise, the normal equations may be used to define it instead</p>
<div class="math notranslate nohighlight">
\[\xi(X) = (J^T J)^{-1} J^T (X - X_1).\]</div>
<h2 id="derivatives">Derivatives<a class="headerlink" href="#derivatives" title="Permalink to this heading">¶</a></h2>
<p>Computing derivatives of basis functions <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> also amounts to computing derivatives of shape functions <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>. Because our shape functions are now defined in reference space, we must use the <a class="reference external" href="https://en.wikipedia.org/wiki/Chain_rule">chain rule of differentiation</a> to compute <span class="math notranslate nohighlight">\(\nabla_X N_i^e(X) = \nabla_X N_l(\xi(X))\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[\nabla_X \phi_i(X) = \nabla_X N_i^e(X) = \nabla_\xi N_l(\xi(X)) \nabla_X \xi(X)\]</div>
<p>for <span class="math notranslate nohighlight">\(X \in \Omega^e\)</span>.</p>
<p>The gradient of the reference shape functions with respect to reference positions is easy enough to compute, since we just need to differentiate polynomials <span class="math notranslate nohighlight">\(\xi_x^a \xi_y^b \xi_z^c\)</span>. The jacobian <span class="math notranslate nohighlight">\(\nabla_X \xi(X)\)</span> of the inverse map is, again, not so trivial in the general case. If a Gauss-Newton algorithm is used to compute <span class="math notranslate nohighlight">\(\xi(X)\)</span> as described above, we need to compute and accumulate gradients of the Gauss-Newton iterations by chain rule. Once again, though, if the map is linear, we can use the previous derivations of the linear inverse map to get <span class="math notranslate nohighlight">\(\nabla_X \xi(X)\)</span> as</p>
<div class="math notranslate nohighlight">
\[\nabla_X \xi(X) = J^{-1}\]</div>
<p>for a square jacobian <span class="math notranslate nohighlight">\(J\)</span>, and</p>
<div class="math notranslate nohighlight">
\[\nabla_X \xi(X) = (J^T J)^{-1} J^T\]</div>
<p>for a non-square jacobian <span class="math notranslate nohighlight">\(J\)</span>.</p>
<h3 id="id2">Summary<a class="headerlink" href="#id2" title="Permalink to this heading">¶</a></h3>
<p>Basis functions <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> are constructed piece-wise in mesh elements <span class="math notranslate nohighlight">\(e\)</span> adjacent to node <span class="math notranslate nohighlight">\(i\)</span> via element shape functions <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>. To evaluate <span class="math notranslate nohighlight">\(\phi_i(X)\)</span>, we find element <span class="math notranslate nohighlight">\(e\)</span> adjacent to node <span class="math notranslate nohighlight">\(i\)</span> containing point <span class="math notranslate nohighlight">\(X\)</span>, and evaluate <span class="math notranslate nohighlight">\(N_i^e(X)\)</span>. The shape functions are polynomials which depend on the geometry of their associated element, and we compute them by inverting a matrix <span class="math notranslate nohighlight">\(P^T\)</span> of polynomials evaluated at element <span class="math notranslate nohighlight">\(e\)</span>’s nodes. To avoid ill-conditioning of the matrix inversion problem, we instead define a reference element that is well-conditioned, and construct reference shape functions <span class="math notranslate nohighlight">\(N_l(\xi)\)</span> there. Evaluating our basis functions in the domain then amounts to <span class="math notranslate nohighlight">\(\phi_i(X) = N_i^e(X) = N_l(\xi(X))\)</span>, where <span class="math notranslate nohighlight">\(\xi(X)\)</span> is the inverse map taking domain positions <span class="math notranslate nohighlight">\(X\)</span> to reference positions <span class="math notranslate nohighlight">\(\xi\)</span>, as opposed to the map <span class="math notranslate nohighlight">\(X(\xi)\)</span> which takes reference positions to domain positions. Gradients of basis functions can be computed by carrying out the chain rule of differentiation through <span class="math notranslate nohighlight">\(N_l(\xi)\)</span> and <span class="math notranslate nohighlight">\(\xi(X)\)</span>. The specific placement of nodes and the associated basis polynomials in reference space defines the type of an FEM element. We present the classic Lagrange element as a simple yet popular choice.</p>
<p>Because functions discretized on an FEM mesh have a linear combination structure <span class="math notranslate nohighlight">\(u(X) \approx \Phi^T u\)</span>, and <span class="math notranslate nohighlight">\(u\)</span> is a simple vector of constant (with respect to <span class="math notranslate nohighlight">\(X\)</span>) coefficients, differential operators <span class="math notranslate nohighlight">\(D(\cdot)\)</span> applied to <span class="math notranslate nohighlight">\(u(X)\)</span> need only be applied to the basis functions <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> by linearity. In other words, <span class="math notranslate nohighlight">\(L(u(X)) = \sum_i u_i L(\phi_i(X))\)</span>. The gradient <span class="math notranslate nohighlight">\(\nabla u(X)\)</span>, for example, amounts to <span class="math notranslate nohighlight">\(\sum_i u_i \nabla \phi_i(X)\)</span>, where we have shown how to evaluate <span class="math notranslate nohighlight">\(\nabla \phi_i(X)\)</span>. The same applies to other differential operators, such as <span class="math notranslate nohighlight">\(\Delta, \nabla^2, \nabla \cdot, \int \partial\)</span>, etc.</p>
<h2 id="spatial-integration">Spatial integration<a class="headerlink" href="#spatial-integration" title="Permalink to this heading">¶</a></h2>
<p>Many of the problems solved by FEM are defined by integration over the domain <span class="math notranslate nohighlight">\(\Omega\)</span>. For example, we have seen that PDEs can be solved with a Galerkin projection, which involves computing <span class="math notranslate nohighlight">\(\int_{\Omega} L(\Phi^T u) \phi_i(X) \partial \Omega\)</span>, where <span class="math notranslate nohighlight">\(L(\cdot)\)</span> is a PDE. Spatial integration also arises when we wish to minimize some quantity “everywhere” in the domain, a very common scenario. For example, suppose we have a function <span class="math notranslate nohighlight">\(h(X)\)</span> which measures temperature in the domain <span class="math notranslate nohighlight">\(\Omega\)</span>, and suppose that there is a heat source in some region <span class="math notranslate nohighlight">\(\Omega_h \subset \Omega\)</span>. Maybe we want to minimize the temperature everywhere in <span class="math notranslate nohighlight">\(\Omega\)</span>, in the presence of such a heat source. Mathematically, we would thus want to minimize the energy <span class="math notranslate nohighlight">\(\int_{\Omega} h(X) \partial \Omega\)</span> subject to <span class="math notranslate nohighlight">\(h(\Omega_h) = h_D\)</span>, where <span class="math notranslate nohighlight">\(h_D\)</span> is the temperature of the heat source.</p>
<p>Thanks to the <a class="reference external" href="https://en.wikipedia.org/wiki/Integral#Conventions">separability of definite integrals</a>, integrals over the domain <span class="math notranslate nohighlight">\(\Omega\)</span> can be broken up into a sum of integrals over element domains <span class="math notranslate nohighlight">\(\Omega^e\)</span>, since elements are non-overlapping and cover the domain. In other words, given some integrand <span class="math notranslate nohighlight">\(F(X)\)</span>,</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} F(X) \partial \Omega = \sum_{e \in E} \int_{\Omega^e} F(X) \partial \Omega.\]</div>
<p>As such, if we know how to compute an element integral, then we know how to compute integrals over the whole domain by summation. However, elements can have many different configurations depending on the problem. Fortunately, we can leverage the method of <a class="reference external" href="https://en.wikipedia.org/wiki/Integration_by_substitution#Substitution_for_multiple_variables">integration by substitution</a> (i.e. change of variables), our fixed reference element with known bounds, and the map <span class="math notranslate nohighlight">\(X(\xi)\)</span> to compute domain element integrals by integrating in the reference element. Mathematically,</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega^e} F(X) \partial \Omega = \int_{\Omega^\text{ref}} F(X(\xi)) |\det \nabla_\xi X| \partial \Omega^\text{ref},\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega^\text{ref}\)</span> is the reference element’s domain. For reference line, quadrilateral and hexahedral elements, the bounds of integration (i.e. the domain of <span class="math notranslate nohighlight">\(\Omega^\text{ref}\)</span>) are <span class="math notranslate nohighlight">\(0 \leq \xi \leq 1\)</span>. For a triangle, the bounds are <span class="math notranslate nohighlight">\(\xi_x \in [0, 1], \xi_y \in [0,1-\xi_x]\)</span>, whereas for tetrahedra, they become <span class="math notranslate nohighlight">\(\xi_x \in [0, 1], \xi_y \in [0, 1- \xi_x], \xi_z \in [0, 1 - \xi_y - \xi_x]\)</span>. If the map <span class="math notranslate nohighlight">\(X(\xi)\)</span> is not square, i.e. the reference element is of lower dimension than the mesh’s embedding dimensions, then the determinant <span class="math notranslate nohighlight">\(\det \nabla_\xi X\)</span> is undefined. In fact, a more general expression would replace <span class="math notranslate nohighlight">\(\det \nabla_\xi\)</span> with <span class="math notranslate nohighlight">\(\Pi_{k} \sigma_k\)</span> where <span class="math notranslate nohighlight">\(\sigma_k\)</span> are <a class="reference external" href="https://en.wikipedia.org/wiki/Singular_value_decomposition">singular values</a> of <span class="math notranslate nohighlight">\(\nabla_\xi X\)</span>. This approach must be used, for example, when using FEM on 3D triangles, where the reference triangle is inherently a 2D object. For the remainder of the text, we will stick to the notation <span class="math notranslate nohighlight">\(\det \nabla_\xi X\)</span>, although the singular value variant of the expression is to be implicitly understood.</p>
<p>Although it is possible to analytically derive computable expressions for these reference integrals, it is often not practical to do so. A more general approach (and sometimes more efficient) approach is to use numerical integration, also known as <a class="reference external" href="https://en.wikipedia.org/wiki/Numerical_integration">*quadrature*</a>. Quadrature <em>rules</em> are pairs of weights <span class="math notranslate nohighlight">\(w_g\)</span> and points <span class="math notranslate nohighlight">\(\xi_g\)</span> for which an integral can be approximated by simple weighted sum of the integrand, without computing antiderivatives, as</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega^\text{ref}} F(X(\xi)) |\det \nabla_\xi X| \partial \Omega^\text{ref} \approx \sum_g w_g F(X(\xi_g)) |\det \nabla_\xi X|.\]</div>
<p>Such weights <span class="math notranslate nohighlight">\(w_g\)</span> and points <span class="math notranslate nohighlight">\(\xi_g\)</span> are often provided in the form of tables by many FEM implementations for common geometries such as the reference line, triangle, quadrilateral, tetrahedral and hexahedral elements. The specific number of pairs (<span class="math notranslate nohighlight">\(w_g\)</span>, <span class="math notranslate nohighlight">\(\xi_g\)</span>) and their values depends on the geometry and the type of integrand. Generally, quadrature rules for polynomial integrands are easily obtainable and are, in fact, exact up to floating point precision. The higher the order of integrand, the higher the number of required pairs (<span class="math notranslate nohighlight">\(w_g\)</span>, <span class="math notranslate nohighlight">\(\xi_g\)</span>) to compute the analytic integral exactly. This statement is relevant, because FEM shape functions are, in fact, polynomials, and integrals over FEM functions become integrals over FEM shape functions, thanks to linearity of the integral operator and the linear combination structure of FEM functions. As an example, consider how</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \sum_i u_i \phi_i(X) \partial \Omega = \sum_i u_i \int_{\Omega} \phi_i(X) \partial \Omega,\]</div>
<p>where we need only know how to integrate <span class="math notranslate nohighlight">\(\int_{\Omega} \phi_i(X) \partial \Omega\)</span>. Many other integral expressions also reduce to integrating simple integrands involving only basis functions <span class="math notranslate nohighlight">\(\phi_i(X)\)</span>. Thus, such integrands are also polynomials, and can be computed exactly via quadrature.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">integrate_element</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="n">Xig</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">detJ</span><span class="p">):</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">wg</span><span class="p">[</span><span class="n">g</span><span class="p">]</span> <span class="o">*</span> <span class="n">F</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">Xig</span><span class="p">[:,</span><span class="n">g</span><span class="p">]))</span> <span class="o">*</span> <span class="n">detJ</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">I</span>

<span class="k">def</span> <span class="nf">integrate_domain</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">wg</span><span class="p">,</span> <span class="n">Xig</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">reference_to_domain_map</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">detJ</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">jacobian_determinants_at_reference_points</span><span class="p">(</span><span class="n">Xig</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">integrate_element</span><span class="p">(</span><span class="n">wg</span><span class="p">,</span> <span class="n">Xig</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">detJ</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">I</span>
</code></pre></div>
</div>
<h2 id="operators">Operators<a class="headerlink" href="#operators" title="Permalink to this heading">¶</a></h2>
<p>Now that we know how to compute shape functions, their derivatives and their integrals, we present a handful of useful FEM operators used to discretize common problems.</p>
<h3 id="shape-function-matrix">Shape function matrix<a class="headerlink" href="#shape-function-matrix" title="Permalink to this heading">¶</a></h3>
<p>Our first operator will simply evaluate an FEM function <span class="math notranslate nohighlight">\(u(X)\)</span> at every quadrature point <span class="math notranslate nohighlight">\(X(\xi_g)\)</span> in every element <span class="math notranslate nohighlight">\(e\)</span>, where <span class="math notranslate nohighlight">\(X(\cdot)\)</span> is to be understood as element <span class="math notranslate nohighlight">\(e\)</span>’s map from the reference element to the domain. Given <span class="math notranslate nohighlight">\(u(\cdot)\)</span>’s coefficient vector <span class="math notranslate nohighlight">\(u\)</span>, we thus wish to compute <span class="math notranslate nohighlight">\(u(X(\xi_g)) = \sum_i u_i \phi(X(\xi_g)) = \Phi(X(\xi_g))^T u\)</span> for every element <span class="math notranslate nohighlight">\(e\)</span> and every quadrature point <span class="math notranslate nohighlight">\(\xi_g\)</span> in the reference element. However, we know that <span class="math notranslate nohighlight">\(\phi_i(X(\xi_g))\)</span> is only non-zero when node <span class="math notranslate nohighlight">\(i\)</span> is part of element <span class="math notranslate nohighlight">\(e\)</span>, so we can safely ignore (i.e. set to zero) all <span class="math notranslate nohighlight">\(\phi_j(X(\xi_g))\)</span> for nodes <span class="math notranslate nohighlight">\(j\)</span> not in element <span class="math notranslate nohighlight">\(e\)</span>. In other words, only the shape functions of element <span class="math notranslate nohighlight">\(e\)</span> need to be evaluated at quadrature points in <span class="math notranslate nohighlight">\(e\)</span>. This results in a highly sparse operator <span class="math notranslate nohighlight">\(N\)</span>, whose (sparse) block rows <span class="math notranslate nohighlight">\(N_e\)</span> are defined as</p>
<div class="math notranslate nohighlight">
\[\begin{split}N_e = \begin{bmatrix}
\phi_1(X(\xi_1)) &amp; \dots &amp; \phi_n(X(\xi_1)) \\
\vdots &amp; \vdots &amp; \vdots \\
\phi_1(X(\xi_q)) &amp; \dots &amp; \phi_n(X(\xi_q)) \\
\end{bmatrix} \in \mathbb{R}^{q \times n},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> is the number of quadrature points and <span class="math notranslate nohighlight">\(n\)</span> is the number of FEM nodes. Compact storage of <span class="math notranslate nohighlight">\(N_e\)</span> would store only the shape function values</p>
<div class="math notranslate nohighlight">
\[\begin{bmatrix} N_l^e(X(\xi_g)) \end{bmatrix} \in \mathbb{R}^{q \times n^e}\]</div>
<p>in a dense matrix using local node indexing <span class="math notranslate nohighlight">\(l\)</span>. These local dense matrices are often named using the prefix “element”, as in “element shape function matrix”, or “element hessian” and so on and so forth.</p>
<p>Our full shape function matrix <span class="math notranslate nohighlight">\(N \in \mathbb{R}^{|E|q \times n}\)</span> is thus sparse, and its application to <span class="math notranslate nohighlight">\(u\)</span></p>
<div class="math notranslate nohighlight">
\[Nu \in \mathbb{R}^{|E|q \times 1}\]</div>
<p>computes <span class="math notranslate nohighlight">\(u(X^e(\xi_g))\)</span>, yielding a vector.</p>
<h3 id="quadrature-matrix">Quadrature matrix<a class="headerlink" href="#quadrature-matrix" title="Permalink to this heading">¶</a></h3>
<p>We introduce a second operator that will enable computing integrals of FEM quantities using matrix operations. Recall from the section on spatial integration that using numerical quadrature, any integral in any element <span class="math notranslate nohighlight">\(e\)</span> with polynomial integrands of order <span class="math notranslate nohighlight">\(p\)</span> can be computed exactly given the quadrature weights <span class="math notranslate nohighlight">\(w_g\)</span> and the jacobian determinants <span class="math notranslate nohighlight">\(|\det \nabla_\xi X(\xi_g)|\)</span> for a polynomial quadrature rule (<span class="math notranslate nohighlight">\(w_g\)</span>, <span class="math notranslate nohighlight">\(\xi_g\)</span>) of order greater than or equal to <span class="math notranslate nohighlight">\(p\)</span>. Hence, any integrand evaluated at <span class="math notranslate nohighlight">\(X(\xi_g)\)</span> simply needs to be multiplied by <span class="math notranslate nohighlight">\(w_g |\det \nabla_\xi X(\xi_g)|\)</span> to be integrated. This hints at the diagonal matrix <span class="math notranslate nohighlight">\(Q \in \mathbb{R}^{|E|q \times |E|q}\)</span>, which we will name the “Quadrature” matrix, whose diagonal blocks are</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q_e = \begin{bmatrix}
w_1 |\det \nabla_\xi X(\xi_1)| &amp; 0 &amp; 0 \\
0 &amp; \ddots &amp; 0 \\
0 &amp; 0 &amp; w_q |\det \nabla_\xi X(\xi_q)| \\
\end{bmatrix} \in \mathbb{R}^{q \times q}\end{split}\]</div>
<p>for every element <span class="math notranslate nohighlight">\(e\)</span>.</p>
<p>This quadrature matrix <span class="math notranslate nohighlight">\(Q\)</span> is essentially a discrete analog of the inner product <span class="math notranslate nohighlight">\(\langle u, v \rangle = \int_\Omega u v \partial \Omega\)</span> of functions <span class="math notranslate nohighlight">\(u, v\)</span> defined on the FEM mesh. For instance, the volume of each domain can be computed easily by the inner product of the unit function, i.e. <span class="math notranslate nohighlight">\(\langle 1, 1 \rangle = \int_\Omega \partial \Omega = 1_{|E|q}^T Q 1_{|E|q}\)</span>, where we have used the vector of all ones <span class="math notranslate nohighlight">\(1_{|E|q} \in \mathbb{R}^{|E|q}\)</span>. The volume of individual elements <span class="math notranslate nohighlight">\(e\)</span> can similarly be computed as</p>
<div class="math notranslate nohighlight">
\[\left[
I_{|E| \times |E|} \otimes 1_{q} \right]^T Q \left[
I_{|E| \times |E|} \otimes 1_{q} \right],\]</div>
<p>where <span class="math notranslate nohighlight">\(\otimes\)</span> is the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a>.</p>
<p>Galerkin projections <span class="math notranslate nohighlight">\(\langle f, \phi \rangle\)</span> also become easy to compute. Consider some function <span class="math notranslate nohighlight">\(f\)</span> discretized at element quadrature points into matrix <span class="math notranslate nohighlight">\(F\)</span>, then we can compute its Galerkin projection as <span class="math notranslate nohighlight">\(N^T Q F\)</span>.</p>
<h3 id="load-vector">Load vector<a class="headerlink" href="#load-vector" title="Permalink to this heading">¶</a></h3>
<p>In the motivating example, we showed how the Poisson equation <span class="math notranslate nohighlight">\(\Delta u(X) = f(X)\)</span> became a linear system <span class="math notranslate nohighlight">\(Au=f\)</span> after FEM discretization, where <span class="math notranslate nohighlight">\(f_i = \int_{\Omega} f(X) \phi_i(X) \partial \Omega\)</span>. However, this form is impractical, because for every different forcing function <span class="math notranslate nohighlight">\(f(X)\)</span>, a different integral expression would have to be generated to compute <span class="math notranslate nohighlight">\(f\)</span>. Instead, we will often discretize “known” forcing functions, i.e. <em>load vectors</em>, as these piece-wise (per element) polynomial functions <span class="math notranslate nohighlight">\(f(X) = f_e(X) \in \mathbb{R}^{d}\)</span> for <span class="math notranslate nohighlight">\(X \in \Omega^e\)</span>. This allows us to compute the <em>load vector</em> <span class="math notranslate nohighlight">\(f\)</span> as</p>
<div class="math notranslate nohighlight">
\[f_i = \int_{\Omega} f(X) \phi_i(X) \partial \Omega = \sum_e \int_{\Omega^e} f_e(X) \phi_i(X) \partial \Omega^e,\]</div>
<p>since the <span class="math notranslate nohighlight">\(f_e(X)\)</span> are polynomial in their corresponding element. If <span class="math notranslate nohighlight">\(f_e(X)\)</span> has order <span class="math notranslate nohighlight">\(p_f\)</span> and <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is of order <span class="math notranslate nohighlight">\(p_\phi\)</span>, then a polynomial quadrature rule of order <span class="math notranslate nohighlight">\(p=p_f + p_\phi\)</span> is exact, and we obtain</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega^e} f_e(X) \phi_i(X) \partial \Omega^e = \sum_g \left[ w_g |\det \nabla_\xi X(\xi_g)| \right] f_e(X(\xi_g)) \phi_i(X(\xi_g)).\]</div>
<p>We can thus construct the matrix <span class="math notranslate nohighlight">\(F \in \mathbb{R}^{|E|q \times d}\)</span>, whose block rows <span class="math notranslate nohighlight">\(F_e \in \mathbb{R}^{q \times d}\)</span> contain values of the forcing function <span class="math notranslate nohighlight">\(f_e\)</span> evaluated at <span class="math notranslate nohighlight">\(e\)</span>’s quadrature points <span class="math notranslate nohighlight">\(X(\xi_g)\)</span>, and compute the load vector <span class="math notranslate nohighlight">\(f\)</span> under Galerkin projection as</p>
<div class="math notranslate nohighlight">
\[f = N^T Q F \in \mathbb{R}^{n \times d}\]</div>
<p>with exact integration, given a quadrature matrix <span class="math notranslate nohighlight">\(Q\)</span> discretized for order <span class="math notranslate nohighlight">\(p\)</span> integrands.</p>
<p>In the special case that <span class="math notranslate nohighlight">\(f(X)\)</span> is piece-wise constant, the element integrals become <span class="math notranslate nohighlight">\(f_e(X) \int_{\Omega^e} \phi_i(X) \partial \Omega^e\)</span> in each element, such that <span class="math notranslate nohighlight">\(\int_{\Omega^e} \phi_i(X) \partial \Omega^e\)</span> can instead be precomputed and re-used for any new piece-wise constant forcing function <span class="math notranslate nohighlight">\(f(X) = f_e(X)\)</span>. In this case, <span class="math notranslate nohighlight">\(p = p_\phi\)</span>, and basis function integrals <span class="math notranslate nohighlight">\(\int_{\Omega^e} \phi_i(X) \partial \Omega^e\)</span> are precomputed into <span class="math notranslate nohighlight">\(B = N^T Q 1_{|E|q}\)</span>. Then, different load vectors can be computed for any piece-wise constant function <span class="math notranslate nohighlight">\(f(X) = f_e(X)\)</span> discretized in <span class="math notranslate nohighlight">\(F\)</span> for a quadrature order <span class="math notranslate nohighlight">\(p\)</span> as</p>
<div class="math notranslate nohighlight">
\[f = B F \in \mathbb{R}^{n \times d}.\]</div>
<h3 id="mass-matrix">Mass matrix<a class="headerlink" href="#mass-matrix" title="Permalink to this heading">¶</a></h3>
<p>Another approach is to directly discretize the forcing function <span class="math notranslate nohighlight">\(f(X) \approx \sum_j f_j \phi_j(X)\)</span> in the same function space as the FEM solution. Under the Galerkin projection, we would thus get</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} f(X) \partial \Omega = \sum_j f_j \int_{\Omega} \phi_i(X) \phi_j(X) \partial \Omega.\]</div>
<p>In matrix notation, this is exactly <span class="math notranslate nohighlight">\(Mf\)</span>, where <span class="math notranslate nohighlight">\(M \in \mathbb{R}^{n \times n}\)</span> and <span class="math notranslate nohighlight">\(f \in \mathbb{R}^{n \times 1}\)</span> and the entries <span class="math notranslate nohighlight">\(M_{ij} = \int_{\Omega} \phi_i(X) \phi_j(X) \partial \Omega\)</span>. The forcing function <span class="math notranslate nohighlight">\(f(X)\)</span> may thus be user-defined purely by specifying function values <span class="math notranslate nohighlight">\(f_i\)</span> at the mesh nodes <span class="math notranslate nohighlight">\(i\)</span>, rather than at mesh elements <span class="math notranslate nohighlight">\(e\)</span> as in the previous section. If <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is a polynomial of order <span class="math notranslate nohighlight">\(p\)</span>, then mass matrix entries have polynomial integrands of order <span class="math notranslate nohighlight">\(2p\)</span>. Thus, the mass matrix can be computed exactly using a polynomial quadrature rule of order <span class="math notranslate nohighlight">\(2p\)</span>.</p>
<p>Using this approach, the earlier Poisson problem would be discretized into <span class="math notranslate nohighlight">\(Au = Mf\)</span>. Many other PDEs involving known functions make the mass matrix appear. The dot product <span class="math notranslate nohighlight">\(u(X)^T v(X)\)</span> of 2 functions <span class="math notranslate nohighlight">\(u(X) = \sum_i u_i \phi_i(X)\)</span> and <span class="math notranslate nohighlight">\(v(X) = \sum_i v_i \phi_i(X)\)</span> discretized in FEM’s solution space, with coefficients vectors <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>, will similarly make the mass matrix appear as <span class="math notranslate nohighlight">\(u^T M v\)</span>. We can thus think of the mass matrix as a suitable inner product matrix which enjoys the desirable property of being symmetric and positive definite.</p>
<p>Again, because each element uniquely contributes to its nodes’ basis function integrals, we can compute and store per-element mass matrices independently as</p>
<div class="math notranslate nohighlight">
\[\begin{split}M^e =
\begin{bmatrix}
\int_{\Omega^e} \phi_1 \phi_1 \partial \Omega^e &amp; \dots &amp; \int_{\Omega^e} \phi_1 \phi_{n^e} \partial \Omega^e \\
\vdots &amp;  &amp; \vdots \\
\int_{\Omega^e} \phi_{n^e} \phi_1 \partial \Omega^e &amp; \dots &amp; \int_{\Omega^e} \phi_{n^e} \phi_{n^e} \partial \Omega^e
\end{bmatrix},\end{split}\]</div>
<p>using local node indices <span class="math notranslate nohighlight">\(l=1,2,\dots,n^e\)</span> which are then accumulated (i.e. summed) into the global mass matrix <span class="math notranslate nohighlight">\(M\)</span> by mapping local indices <span class="math notranslate nohighlight">\(l\)</span> into corresponding global indices <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span> for rows and columns. We call these the element mass matrices.</p>
<p>It is possible to associate physical meaning to the mass matrix by injecting into its integral form a measure of mass density <span class="math notranslate nohighlight">\(\rho\)</span> (i.e. grams per unit volume). If the mass density is specified as piece-wise constants (per element) <span class="math notranslate nohighlight">\(\rho_e\)</span>, then we simply scale each element mass matrix as <span class="math notranslate nohighlight">\(\rho_e M^e\)</span> and sum the scaled element mass matrices into the global mass matrix <span class="math notranslate nohighlight">\(M\)</span>.</p>
<p>If we use our previously defined quadrature matrix <span class="math notranslate nohighlight">\(Q\)</span> and shape function matrix <span class="math notranslate nohighlight">\(N\)</span> of quadrature order <span class="math notranslate nohighlight">\(2p\)</span>, then we can simply write</p>
<div class="math notranslate nohighlight">
\[M = N^T Q N \in \mathbb{R}^{n \times n}.\]</div>
<p>With this construction, the inner product structure of <span class="math notranslate nohighlight">\(M\)</span> is even more obvious. The product <span class="math notranslate nohighlight">\(u^T M v = u^T N^T Q N v\)</span> immediately reveals that we are integrating <span class="math notranslate nohighlight">\(\langle u, v \rangle\)</span> for functions <span class="math notranslate nohighlight">\(u, v\)</span> discretized on the mesh using shape functions <span class="math notranslate nohighlight">\(N\)</span>.</p>
<h3 id="gradient-matrix">Gradient matrix<a class="headerlink" href="#gradient-matrix" title="Permalink to this heading">¶</a></h3>
<p>Computing the gradient <span class="math notranslate nohighlight">\(\nabla u(X)\)</span> amounts to simply <span class="math notranslate nohighlight">\(\sum_i u_i \nabla \phi_i(X)\)</span>. This leads to defining <span class="math notranslate nohighlight">\(G\)</span> similarly to <span class="math notranslate nohighlight">\(N\)</span>, except we now inject the shape function derivatives <span class="math notranslate nohighlight">\(\frac{\partial \phi_i(X(\xi_g))}{\partial X_k}\)</span> for the <span class="math notranslate nohighlight">\(k^\text{th}\)</span> dimension, evaluated at element <span class="math notranslate nohighlight">\(e\)</span>’s quadrature points <span class="math notranslate nohighlight">\(X(\xi_g)\)</span>, in the <span class="math notranslate nohighlight">\(e^{\text{th}}\)</span> block row.</p>
<p>This leads to defining the Galerkin gradient matrix for <span class="math notranslate nohighlight">\(X\)</span> of dimensions <span class="math notranslate nohighlight">\(d\)</span> via its block rows, as</p>
<div class="math notranslate nohighlight">
\[\begin{split}G^k_{e} = \begin{bmatrix}
\frac{\partial \phi_1(X(\xi_1))}{\partial X_k} &amp; \dots &amp; \frac{\partial \phi_n(X(\xi_1))}{\partial X_k} \\
\vdots &amp; \ddots &amp; \vdots\\
\frac{\partial \phi_1(X(\xi_q))}{\partial X_k} &amp; \dots &amp; \frac{\partial \phi_n(X(\xi_q))}{\partial X_k} \\
\end{bmatrix} \in \mathbb{R}^{q \times n}.\end{split}\]</div>
<p>As in the case of <span class="math notranslate nohighlight">\(N\)</span>, only the shape function derivatives of element <span class="math notranslate nohighlight">\(e\)</span> are non-zero in this block row, such that <span class="math notranslate nohighlight">\(G^k_e\)</span> is sparse. We store the gradients separately per dimension, as</p>
<div class="math notranslate nohighlight">
\[\begin{split}G^k = \begin{bmatrix}
G^k_1 \\
\vdots \\
G^k_{|E|} \\
\end{bmatrix} \in \mathbb{R}^{|E|q \times n},\end{split}\]</div>
<p>and then stack them vertically into</p>
<div class="math notranslate nohighlight">
\[\begin{split}G = \begin{bmatrix}
G^1 \\
\vdots \\
G^d
\end{bmatrix} \in \mathbb{R}^{d|E|q \times n}.\end{split}\]</div>
<p>The application of <span class="math notranslate nohighlight">\(G\)</span> onto <span class="math notranslate nohighlight">\(u\)</span> thus computes each spatial derivative of <span class="math notranslate nohighlight">\(u\)</span> at element quadrature points. Each <span class="math notranslate nohighlight">\(G^k u\)</span> computes the <span class="math notranslate nohighlight">\(k^\text{th}\)</span> spatial derivative of <span class="math notranslate nohighlight">\(u(X)\)</span> at all element quadrature points, and each <span class="math notranslate nohighlight">\(G^k_e u\)</span> computes its <span class="math notranslate nohighlight">\(k^\text{th}\)</span> spatial derivative at element <span class="math notranslate nohighlight">\(e\)</span>’s quadrature points.</p>
<p>If the gradient appears in the problem (i.e. PDE or other) itself, and the problem has been closed under Galerkin projection, we must now compute the “Galerkin” version of the gradient, i.e. <span class="math notranslate nohighlight">\(\int_{\Omega} \nabla u(X) \phi_i(X) \partial \Omega = \langle \nabla u, \phi_i \rangle\)</span>. By approximation and linearity of the gradient operator, such an expression becomes</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \nabla u(X) \phi_i(X) \partial \Omega = \sum_j u_j \int_{\Omega} \phi_i(X) \nabla \phi_j(X) \partial \Omega.\]</div>
<p>If <span class="math notranslate nohighlight">\(\phi_i\)</span> has order <span class="math notranslate nohighlight">\(p\)</span>, then <span class="math notranslate nohighlight">\(\phi_i \nabla \phi_j\)</span> has order <span class="math notranslate nohighlight">\(2p - 1\)</span>. Thus, armed with the quadrature matrix <span class="math notranslate nohighlight">\(Q\)</span> and shape function matrix <span class="math notranslate nohighlight">\(N\)</span> of quadrature order <span class="math notranslate nohighlight">\(2p - 1\)</span>,</p>
<div class="math notranslate nohighlight">
\[\left[ I_{d \times d} \otimes N^T Q \right] G u = \bar{G} u\]</div>
<p>computes the gradient in the Galerkin sense, where <span class="math notranslate nohighlight">\(I_{d \times d}\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\bar{G}\)</span> is the Galerkin projected gradient operator. Its entries are</p>
<div class="math notranslate nohighlight">
\[\bar{G}^k_{ij} = \int_{\Omega} \phi_i(X) \frac{\partial \phi_j(X)}{\partial X_k} \partial \Omega\]</div>
<p>for <span class="math notranslate nohighlight">\(k=1,2,\dots,d\)</span>.</p>
<h3 id="laplacian-matrix">Laplacian matrix<a class="headerlink" href="#laplacian-matrix" title="Permalink to this heading">¶</a></h3>
<p>The Poisson problem discretized the Laplacian matrix into <span class="math notranslate nohighlight">\(A\)</span> where <span class="math notranslate nohighlight">\(A_{ij} = \int_{\Omega} \phi_i(X) \Delta \phi_j(X) \partial \Omega\)</span>. However, this results in a non-symmetric matrix, and requires shape functions of order <span class="math notranslate nohighlight">\(p \geq 2\)</span>, meaning we wouldn’t be able to use linear shape functions to solve a problem involving the Laplacian of the solution. Thus, in practice, we will make use of multivariable <a class="reference external" href="https://en.wikipedia.org/wiki/Green%27s_identities">integration by parts</a>, i.e. <a class="reference external" href="https://en.wikipedia.org/wiki/Green%27s_identities">Green’s identities</a>, to transform <span class="math notranslate nohighlight">\(\Delta u(X)\)</span> into</p>
<div class="math notranslate nohighlight">
\[\sum_j u_j \int_{\Omega} \phi_i(X) \Delta \phi_j(X) \partial \Omega = \sum_j u_j
\left[
\int_{\Omega} -\nabla \phi_i(X) \cdot \nabla \phi_j(X) \partial \Omega +
\int_{\partial \Omega} \phi_i(X) \nabla \phi_j(X) \cdot n \partial S
\right].\]</div>
<div class="math notranslate nohighlight">
\[Au = Lu + Nu\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\int_{\partial \Omega} \partial S\)</span> is to be interpreted as a boundary integral (over <span class="math notranslate nohighlight">\(\Omega\)</span>’s boundary) with <span class="math notranslate nohighlight">\(n\)</span> being the boundary’s normal. The integration by parts reveals the symmetric Laplacian matrix <span class="math notranslate nohighlight">\(L \in \mathbb{R}^{n \times n}\)</span>, and the Neumann matrix <span class="math notranslate nohighlight">\(N \in \mathbb{R}^{n \times n}\)</span>. In fact, <span class="math notranslate nohighlight">\(L\)</span> is desirably both symmetric and negative semi-definite (with only rank-1 deficiency). If Neumann boundary conditions have been specified as a known function</p>
<div class="math notranslate nohighlight">
\[g(X) = \nabla u(X) \cdot n\]</div>
<p>on the domain’s boundary, i.e. <span class="math notranslate nohighlight">\(X \in \partial \Omega\)</span>, then we replace <span class="math notranslate nohighlight">\(Nu\)</span> by <span class="math notranslate nohighlight">\(g \in \mathbb{R}^{n \times n}\)</span> such that <span class="math notranslate nohighlight">\(g_i = \int_{\partial \Omega} g(X) \phi_i(X) \partial S\)</span>. Because this integral is defined over the boundary of the FEM meshing of <span class="math notranslate nohighlight">\(\Omega\)</span>, we can similarly extract the boundary mesh for <span class="math notranslate nohighlight">\(\partial \Omega\)</span>, preserving node indexing. We can then discretize <span class="math notranslate nohighlight">\(g(X)\)</span> on this boundary mesh using FEM once again as either a load vector if <span class="math notranslate nohighlight">\(g(X)\)</span> is defined on boundary faces, or as <span class="math notranslate nohighlight">\(Mg\)</span> using the boundary mesh’s mass matrix <span class="math notranslate nohighlight">\(M\)</span> and coefficients <span class="math notranslate nohighlight">\(g\)</span> defined on boundary vertices. There are many cases where the Neumann boundary conditions are even simpler, however, i.e. when <span class="math notranslate nohighlight">\(g(X) = \nabla u(X) \cdot n = 0\)</span>, in which case the Laplacian matrix is exactly <span class="math notranslate nohighlight">\(L\)</span>. The resulting Poisson problem would then be <span class="math notranslate nohighlight">\(Lu=f\)</span>, which is a symmetric negative semi-definite linear system which can be solved efficiently.</p>
<p>The matrix <span class="math notranslate nohighlight">\(L\)</span> is quite famous and is equivalent to the so-called “<a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Laplace_operator#Mesh_Laplacians">cotangent Laplacian</a>” or the “<a class="reference external" href="https://en.wikipedia.org/wiki/Laplace%E2%80%93Beltrami_operator">Laplace-Beltrami</a>” operator mentioned in the literature, for the case of triangular meshes embedded in 3D. Instead of the general derivation presented in this document, when assuming linear shape functions, it is possible to derive quite elegant analytic expressions involving the cotangent function to compute its entries. In our Physics Based Animation Toolkit, we also like to refer to <span class="math notranslate nohighlight">\(L\)</span> as the symmetric part of the Laplacian matrix. If <span class="math notranslate nohighlight">\(\phi_i(X)\)</span> is of polynomial order <span class="math notranslate nohighlight">\(p\)</span>, then <span class="math notranslate nohighlight">\(L\)</span>’s integrands are polynomials of order <span class="math notranslate nohighlight">\(2(p-1)\)</span>. A polynomial quadrature rule of order <span class="math notranslate nohighlight">\(2(p-1)\)</span> is thus sufficient for exact computation of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p>The matrix <span class="math notranslate nohighlight">\(L\)</span> can be constructed using previously defined operators. Using the matrices <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(G\)</span> of appropriate quadrature order,</p>
<div class="math notranslate nohighlight">
\[L = -G^T \left[ I_{d \times d} \otimes Q \right] G \in \mathbb{R}^{n \times n}.\]</div>
<h3 id="divergence-matrix">Divergence matrix<a class="headerlink" href="#divergence-matrix" title="Permalink to this heading">¶</a></h3>
<p>Interestingly, we can discretize the <a class="reference external" href="https://en.wikipedia.org/wiki/Divergence">divergence</a> operator by simply transposing the gradient matrix, i.e. <span class="math notranslate nohighlight">\(D = G^T \in \mathbb{R}^{n \times d|E|q}\)</span>. Given some vector field <span class="math notranslate nohighlight">\(F(X)\)</span> discretized at element quadrature points <span class="math notranslate nohighlight">\(X(\xi_g)\)</span>, where each scalar field component <span class="math notranslate nohighlight">\(F_k(X)\)</span> of <span class="math notranslate nohighlight">\(F(X)\)</span> has been discretized into <span class="math notranslate nohighlight">\(F_k \in \mathbb{R}^{|E|q \times 1}\)</span> and stacked into <span class="math notranslate nohighlight">\(F \in \mathbb{R}^{d|E|q \times 1}\)</span>,</p>
<div class="math notranslate nohighlight">
\[DF = G^T F \in \mathbb{R}^{n \times 1}\]</div>
<p>computes its divergence. However, in the previous construction of the Laplacian, or more precisely, the symmetric part of the Galerkin projected Laplacian, we had that</p>
<div class="math notranslate nohighlight">
\[L = -G^T \left[ I_{d \times d} \otimes Q \right] G = \left[ -D \left(I_{d \times d} \otimes Q \right) \right] G,\]</div>
<p>where the divergence operator <span class="math notranslate nohighlight">\(D\)</span> must act on the gradient <span class="math notranslate nohighlight">\(G\)</span> of an FEM function through integration. As such, when solving problems involving divergence, such as least-squares gradient matching problems, i.e. the Poisson problem</p>
<div class="math notranslate nohighlight">
\[\min_u ||\nabla u - F||_2^2 \leftrightarrow \Delta u = \nabla \cdot F ,\]</div>
<p>the divergence operator should act on the target vector field <span class="math notranslate nohighlight">\(F(X)\)</span> in the integrated (i.e. Galerkin) sense. In matrix notation, we discretize the divergence of the target vector field <span class="math notranslate nohighlight">\(F(X)\)</span> as <span class="math notranslate nohighlight">\(-D \left[ I_{d \times d} \otimes Q \right] F\)</span>, for discrete <span class="math notranslate nohighlight">\(F\)</span> constructed as in previous examples.</p>
<h2 id="boundary-conditions">Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this heading">¶</a></h2>
<p>Neumann boundary conditions are imposed values on the gradient of the problem’s solution. These Neumann boundary conditions are often called “natural” boundary conditions, because they are implicitly encoded in the problem (where a laplacian appears) and appear “naturally” when applying Green’s identities (see previous subsection), i.e. we can enforce them simply by introducing an extra forcing vector in the discretized linear system.</p>
<p>Dirichlet boundary conditions, i.e. “essential” boundary conditions, are imposed on the problem’s solution itself (as opposed to its derivatives) and are necessary to make our PDEs well-determined (i.e. not rank-deficient). It is often the case that we can impose Dirichlet boundary conditions directly on the FEM mesh’s nodes <span class="math notranslate nohighlight">\(i\)</span>, by simply constraining its associated coefficients <span class="math notranslate nohighlight">\(u_i = d_i\)</span> for some known value <span class="math notranslate nohighlight">\(d_i\)</span>. This is the same as saying, in the continuous case, that <span class="math notranslate nohighlight">\(u(X_i) = d_i\)</span>. Because of the Kronecker delta property on FEM basis functions, <span class="math notranslate nohighlight">\(u(X_i) = u_i \phi_i(X_i) = u_i\)</span>, and so <span class="math notranslate nohighlight">\(u_i = d_i\)</span> for Dirichlet constrained nodes. This approach makes it particularly easy to enforce Dirichlet boundary conditions numerically, as it essentially removes degrees of freedom out of a matrix equation. Consider the linear system <span class="math notranslate nohighlight">\(Ax=b\)</span> discretizing some problem via FEM. Assume that the vector <span class="math notranslate nohighlight">\(x\)</span> has been partitioned into a vector of unknowns <span class="math notranslate nohighlight">\(x_u\)</span> and known values <span class="math notranslate nohighlight">\(x_k = d_k\)</span> for Dirichlet imposed values <span class="math notranslate nohighlight">\(d_k\)</span>. The same partitioning may be applied to the rows and columns of matrix <span class="math notranslate nohighlight">\(A\)</span> and similarly to the right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. We thus get that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
A_{uu} &amp; A_{uk} \\
A_{ku} &amp; A_{kk}
\end{bmatrix}
\begin{bmatrix}
 x_u \\
 x_k
\end{bmatrix} =
\begin{bmatrix}
b_u \\
b_k
\end{bmatrix}.\end{split}\]</div>
<p>The unknowns are thus obtained by solving a reduced problem</p>
<div class="math notranslate nohighlight">
\[A_{uu} x_u = b_u - A_{uk} d_k.\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(A_{uu}\)</span> preserves symmetry if <span class="math notranslate nohighlight">\(A\)</span> is symmetric, and similarly for positive (or negative) (semi-)definiteness.</p>
<p>In the general case, however, it might be the case that Dirichlet boundary conditions cannot be imposed at the nodes. In this case, we might need to enforce Dirichlet boundary conditions as constraints to an optimization problem. For example, our discretized Poisson problem could become the equality constrained minimization</p>
<div class="math notranslate nohighlight">
\[Au = f \longrightarrow \min_u \frac{1}{2}||Au - f||_2^2
\quad\text{ s.t. }\quad
Du_D - d_D = 0 ,\]</div>
<p>where <span class="math notranslate nohighlight">\(Du_D - d_D = 0\)</span> discretizes the continuous constraint <span class="math notranslate nohighlight">\(\int_{\partial \Omega^D} u(X) \partial S - d(X) = 0\)</span> using FEM.</p>
<h2 id="vector-valued-functions">Vector-valued functions<a class="headerlink" href="#vector-valued-functions" title="Permalink to this heading">¶</a></h2>
<p>In many cases, we might want to discretize vector-valued functions using FEM. For example, we might want to model some displacement field in the domain, as is the case in elasticity/deformation. Suppose that <span class="math notranslate nohighlight">\(u(X): \Omega \longrightarrow \mathbb{R}^d\)</span> for some <span class="math notranslate nohighlight">\(d\)</span>, i.e. <span class="math notranslate nohighlight">\(u(X)\)</span> maps domain positions to some <span class="math notranslate nohighlight">\(d\)</span>-dimensional quantity. In this case, we can simply consider each scalar component <span class="math notranslate nohighlight">\(u_k(X)\)</span> of <span class="math notranslate nohighlight">\(u(X)\)</span> as a function. Thus, we can discretize each <span class="math notranslate nohighlight">\(u_k(X)\)</span> using FEM and obtain <span class="math notranslate nohighlight">\(d\)</span> coefficient vectors <span class="math notranslate nohighlight">\(u_k \in \mathbb{R}^n\)</span>. All the operators that we have already defined can then directly be applied to each <span class="math notranslate nohighlight">\(u_k\)</span> independently. In matrix notation, we may horizontally stack the <span class="math notranslate nohighlight">\(u_k\)</span> as columns into some matrix <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{n \times d}\)</span>, and multiply <span class="math notranslate nohighlight">\(U\)</span> from the left using operators <span class="math notranslate nohighlight">\(M, L, G\)</span>. The product <span class="math notranslate nohighlight">\(LU\)</span> would compute the Laplacian of each scalar component <span class="math notranslate nohighlight">\(u_k(X)\)</span> of <span class="math notranslate nohighlight">\(u(X)\)</span>, while <span class="math notranslate nohighlight">\(GU\)</span> would compute their gradients. The load vector can similarly be defined as considering each <span class="math notranslate nohighlight">\(u_k(X)\)</span> as its own separate forcing function, resulting in a matrix <span class="math notranslate nohighlight">\(F \in \mathbb{R}^{n \times d}\)</span> after discretization.</p>
<p>In other situations, however we may wish to concatenate the coefficients <span class="math notranslate nohighlight">\(u_k\)</span> into a single vector <span class="math notranslate nohighlight">\(u \in \mathbb{R}^{nd}\)</span>. This leads to 2 options:</p>
<ol class="arabic simple">
<li><p>Stack each <span class="math notranslate nohighlight">\(u_k\)</span> vertically.</p></li>
<li><p>Interleave all the <span class="math notranslate nohighlight">\(u_k\)</span>.</p></li>
</ol>
<p>By interleaving, we mean that if the <span class="math notranslate nohighlight">\(k^{\text{th}}\)</span> coefficient vector <span class="math notranslate nohighlight">\(u_k\)</span> has coefficients <span class="math notranslate nohighlight">\(u_{ik}\)</span>, then the resulting “interleaved” vector</p>
<div class="math notranslate nohighlight">
\[u = \begin{bmatrix} u_{11} &amp; \dots &amp; u_{n1} &amp; \dots &amp; u_{1d} &amp; \dots &amp; u_{nd} \end{bmatrix}^T\]</div>
<p>Practically, this just means that option 1 flattens the matrix <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{n \times d}\)</span> by stacking its column vertically, and option 2 flattens <span class="math notranslate nohighlight">\(U\)</span> by stacking its transposed rows vertically. For both options, our FEM operators <span class="math notranslate nohighlight">\(M, L, G\)</span> can adjust to <span class="math notranslate nohighlight">\(u\)</span> by using the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a>. Our new operators <span class="math notranslate nohighlight">\(A = M, L, G\)</span> take the following forms for the corresponding options</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(A_{nd \times nd} = I_{d \times d} \otimes A\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(A_{nd \times nd} = A \otimes I_{d \times d}\)</span></p></li>
</ol>
<p>The new load vector <span class="math notranslate nohighlight">\(f \in \mathbb{R}^{nd}\)</span> can be obtained from <span class="math notranslate nohighlight">\(F\)</span> in the same way as <span class="math notranslate nohighlight">\(u\)</span> was obtained from <span class="math notranslate nohighlight">\(U\)</span>.</p>
<p>In the continuous setting, FEM discretized functions (i.e. solution, forcing function, etc.) are now written in the following equivalent forms</p>
<div class="math notranslate nohighlight">
\[u(X) = \sum_i \left[I_{d \times d} \otimes \phi_i(X)\right] u_i = \sum_i \phi_i(X) u_i,\]</div>
<p>and their gradients/jacobians become</p>
<div class="math notranslate nohighlight">
\[\nabla u(X) = \sum_i u_i \nabla \phi_i(X),\]</div>
<p>where <span class="math notranslate nohighlight">\(u_i\)</span> is a column vector, while the gradient <span class="math notranslate nohighlight">\(\nabla \phi_i(X)\)</span> is a row vector, i.e. <span class="math notranslate nohighlight">\(u_i \nabla \phi_i(X)\)</span> is their outer product.</p>
<h2 id="limitations">Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h2>
<p>While FEM remains an invaluable tool for scientific computing, it is not without its drawbacks. One of its main drawbacks is FEM’s reliance on an appropriate meshing of the domain. Indeed, for FEM discretized problems to be well-conditioned, its element geometries must be “regular”. The well-known paper <a class="reference external" href="https://people.eecs.berkeley.edu/~jrs/papers/elemj.pdf">What is a good linear finite element?</a> details this phenomenon in depth. Current meshing tools may take enormous amounts of computational resources (memory, runtime) to produce acceptable outputs. Additionally, it is not guaranteed that any domain <em>can</em> be meshed with current tools. In the realm of computer graphics, geometries are extremely complex, i.e. they exhibit fine details, are high resolution, have highly varying structural qualities (like thin structures, high curvatures) in different regions, and may be poorly authored (among other potential obstacles). In such cases, current tools may break down, or FEM will likely struggle with the quality of their output. Even if high quality meshes of such complex geometries are obtained, their resolution may be so high that solving linear systems of equations arising from FEM will be extremely slow. Modern approaches such as <a class="reference external" href="https://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf">Monte Carlo Geometry Processing</a> and its extensions, <a class="reference external" href="https://riouxld21.github.io/research/publication/2022-mcfluid/">Monte Carlo Fluids</a> tackle this exact problem. <a class="reference external" href="https://en.wikipedia.org/wiki/Meshfree_methods">Meshless methods</a> also exist to sidestep the mesh generation preprocess to FEM, among other such alternative approaches that I am simply not aware of. In the particular case of triangle mesh FEM, <a class="reference external" href="https://nmwsharp.com/media/papers/int-tri-course/int_tri_course.pdf">intrinsic triangulations</a> also enable a high level of robustness to mesh ill-conditioning.</p>
<h2 id="workshops">Workshops<a class="headerlink" href="#workshops" title="Permalink to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p><a class="reference external" href="./W1.ipynb">pbatoolkit.fem</a></p></li>
<li><p><a class="reference external" href="./W2.ipynb">Heat diffusion</a></p></li>
<li><p><a class="reference external" href="./W3.ipynb">Harmonic solutions</a></p></li>
<li><p><a class="reference external" href="./W4.ipynb">Least squares and Poisson problems</a></p></li>
<li><p><a class="reference external" href="./W5.ipynb">Lagrange elements</a></p></li>
</ol>


  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Oct 22, 2024
    
  </small>
</div>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </a>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="getting_started.html" class="md-footer__link md-footer__link--prev" aria-label="Previous: Tutorial" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Tutorial
            </div>
          </div>
        </a>
      
      
        
        <a href="../contributing.html" class="md-footer__link md-footer__link--next" aria-label="Next: Contributing" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Contributing
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2024-2024, Quoc-Minh Ton-That; MIT License.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    6.2.1.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.expand", "navigation.tabs", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "toc.follow", "content.tabs.link"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "version": {"provider": "mike", "staticVersions": null, "versionPath": ""}}</script>
    
      
        <script src="../_static/sphinx_immaterial_theme.f9d9eeeb247ace16c.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script id="MathJax-script" src="../_static/mathjax/tex-mml-chtml.js"></script>
    
  </body>
</html>